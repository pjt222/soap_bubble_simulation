# Key Development Insights

This document captures important lessons learned during the development of the soap bubble simulation.

## Table of Contents

1. [Mesh Topology: UV Sphere vs Icosphere](#mesh-topology-uv-sphere-vs-icosphere)
2. [WGSL Uniform Buffer Alignment](#wgsl-uniform-buffer-alignment)
3. [egui Depth Buffer Configuration](#egui-depth-buffer-configuration)
4. [WSL2 Display Configuration](#wsl2-display-configuration)
5. [Thin-Film Interference Implementation](#thin-film-interference-implementation)
6. [Animation: Camera Rotation vs Geometry Rotation](#animation-camera-rotation-vs-geometry-rotation)
7. [MSAA (Multi-Sample Anti-Aliasing) Implementation](#msaa-multi-sample-anti-aliasing-implementation)
8. [LOD (Level of Detail) System](#lod-level-of-detail-system)
9. [GPU Drainage Simulation](#gpu-drainage-simulation)
10. [Marangoni Effect Implementation](#marangoni-effect-implementation)
11. [Multi-Bubble Foam System](#multi-bubble-foam-system)
12. [Edge Smoothing Modes](#edge-smoothing-modes)

---

## Mesh Topology: UV Sphere vs Icosphere

### Problem

When using an icosphere mesh, visible **zigzag seam artifacts** appeared at the equator. These artifacts were caused by UV coordinate discontinuities where the texture wraps around.

### Root Cause

Icospheres are generated by subdividing an icosahedron. The UV mapping creates a seam where U coordinates jump from 1.0 back to 0.0. When interpolating across triangle edges that span this seam, the GPU interpolates through all intermediate values (e.g., 0.9 → 0.1 interpolates as 0.9 → 0.5 → 0.1 instead of wrapping).

### Solution

Two complementary fixes:

1. **Switch to UV sphere mesh** - A latitude/longitude grid where UV coordinates are naturally continuous within each quad, and the seam is confined to a single meridian.

2. **Use normal vectors instead of UVs for thickness calculation** - The interpolated normal vector is always continuous across the sphere surface. The shader computes film thickness from the normal's Y-component (for drainage) rather than UV coordinates:

```wgsl
fn get_film_thickness(normal: vec3<f32>, time: f32) -> f32 {
    let base = bubble.base_thickness_nm;
    // Drainage based on normal.y (continuous, no seam)
    let drainage_factor = 0.3 * (1.0 - normal.y) * 0.5;
    return base * (1.0 - drainage_factor);
}
```

### Lesson Learned

When working with spherical geometry, prefer using the normal vector for spatial calculations rather than UV coordinates. Normals are inherently continuous on smooth surfaces.

---

## WGSL Uniform Buffer Alignment

### Problem

Runtime validation error:
```
Buffer is bound with size 48 where the shader expects 64 in group[0] compact index 1
```

### Root Cause

WGSL and Rust have different alignment rules for vector types:

| Type | WGSL Size | WGSL Alignment | Rust `[f32; 3]` Size | Rust Alignment |
|------|-----------|----------------|----------------------|----------------|
| `vec3<f32>` | 12 bytes | **16 bytes** | 12 bytes | 4 bytes |

When a WGSL struct contains `vec3<f32>`, the following member must start at a 16-byte boundary. This inflates the struct size. Rust's `#[repr(C)]` doesn't add this padding automatically.

### Example

```wgsl
// WGSL struct - total size: 64 bytes
struct BubbleUniform {
    a: f32,           // offset 0, size 4
    b: f32,           // offset 4, size 4
    // ... 7 more f32s
    i: f32,           // offset 32, size 4
    _padding: vec3<f32>, // offset 48 (aligned to 16!), size 12
    // struct padded to 64 bytes (multiple of max alignment 16)
};
```

```rust
// Rust struct - total size: 48 bytes
#[repr(C)]
struct BubbleUniform {
    a: f32,           // offset 0
    // ...
    i: f32,           // offset 32
    _padding: [f32; 3], // offset 36, size 12 (no alignment padding!)
}
```

### Solution

Avoid `vec3<f32>` in uniform structs. Use separate `f32` fields:

```wgsl
// Fixed WGSL struct - total size: 48 bytes
struct BubbleUniform {
    // ... 9 data fields ...
    _padding1: f32,
    _padding2: f32,
    _padding3: f32,
};
```

### Alternative Solutions

1. Use `#[repr(C, align(16))]` in Rust and add explicit padding
2. Use `vec4<f32>` instead of `vec3<f32>` (both have 16-byte alignment)
3. Use the `bytemuck` crate with careful size assertions

### Note: Applies to All vec3 Types

The 16-byte alignment rule applies to `vec3<u32>` as well, not just `vec3<f32>`. When using `vec3<u32>` for padding in uniform buffers, the same size mismatch occurs. Always use separate scalar fields:

```wgsl
// BAD - vec3<u32> has 16-byte alignment, causing hidden padding
_padding: vec3<u32>,

// GOOD - three separate u32 fields, predictable 12-byte size
_padding1: u32,
_padding2: u32,
_padding3: u32,
```

### Lesson Learned

Always verify uniform buffer sizes match between Rust and WGSL. Avoid `vec3` in uniforms; prefer separate scalars or `vec4`.

---

## egui Depth Buffer Configuration

### Problem

Runtime validation error when rendering egui after the 3D scene:
```
wgpu error: Validation Error - Incompatible depth-stencil attachment format
```

### Root Cause

The egui-wgpu renderer's depth format configuration must exactly match the render pass depth attachment:

- If `egui_wgpu::Renderer::new()` specifies `Some(Depth32Float)`, the render pass **must** have a matching depth attachment
- If egui renderer specifies `None`, the render pass **must not** have a depth attachment

### Solution

Choose one consistent approach:

**Option A: egui without depth (simpler)**
```rust
// Renderer creation
let egui_renderer = egui_wgpu::Renderer::new(&device, surface_format, None, 1, false);

// Render pass
let render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
    depth_stencil_attachment: None,
    // ...
});
```

**Option B: egui with depth (if needed for z-ordering)**
```rust
// Renderer creation
let egui_renderer = egui_wgpu::Renderer::new(
    &device,
    surface_format,
    Some(wgpu::TextureFormat::Depth32Float),
    1,
    false
);

// Render pass - must include depth attachment
let render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
    depth_stencil_attachment: Some(wgpu::RenderPassDepthStencilAttachment {
        view: &depth_texture_view,
        depth_ops: Some(wgpu::Operations {
            load: wgpu::LoadOp::Load,  // Preserve 3D scene depth
            store: wgpu::StoreOp::Store,
        }),
        stencil_ops: None,
    }),
    // ...
});
```

### Lesson Learned

When integrating egui with a 3D rendering pipeline, explicitly decide on depth buffer usage and ensure consistency between renderer initialization and render pass configuration.

---

## WSL2 Display Configuration

### Problem

Window creation fails or renders incorrectly on WSL2 with various display-related errors.

### Root Cause

WSL2 can attempt to use Wayland (via WSLg) but many applications work better with X11. Additionally, the display server configuration may be incomplete.

### Solution

Force X11 backend and unset Wayland display:

```bash
WAYLAND_DISPLAY= WINIT_UNIX_BACKEND=x11 ./target/release/soap-bubble-sim
```

### Environment Variables

| Variable | Value | Purpose |
|----------|-------|---------|
| `WAYLAND_DISPLAY` | (empty) | Disable Wayland detection |
| `WINIT_UNIX_BACKEND` | `x11` | Force winit to use X11 |

### Additional Notes

- Ensure an X11 server is running (VcXsrv, X410, or WSLg's built-in X server)
- For VcXsrv, use "Disable access control" option
- Export `DISPLAY=:0` if not set automatically

### Lesson Learned

WSL2 graphics require explicit backend configuration. Always provide fallback instructions for WSL users.

---

## Thin-Film Interference Implementation

### Physics Overview

Thin-film interference occurs when light waves reflected from the front and back surfaces of a thin film interfere with each other.

### Key Equations

**Optical path difference:**
```
δ = 2 * n_film * d * cos(θ_t) + λ/2
```

**Snell's law for transmission angle:**
```
sin(θ_t) = sin(θ_i) * n_air / n_film
cos(θ_t) = sqrt(1 - sin²(θ_t))
```

**Phase difference:**
```
φ = 2π * δ / λ
```

**Interference intensity:**
```
I = (1 + cos(φ)) / 2
```

### Implementation Details

1. **RGB wavelengths** - Compute interference separately for R (650nm), G (532nm), B (450nm)

2. **Fresnel reflection** - Use Schlick approximation for efficiency:
   ```
   R = R₀ + (1 - R₀)(1 - cos(θ))⁵
   R₀ = ((n_film - 1) / (n_film + 1))²
   ```

3. **Intensity scaling** - Physical thin-film reflections are weak (~4%); scale up for visibility

4. **Phase shift** - Include π phase shift from reflection at the denser medium (outer surface)

### WGSL Implementation

```wgsl
fn thin_film_interference(thickness_nm: f32, cos_theta: f32, n_film: f32) -> vec3<f32> {
    let wavelengths = vec3<f32>(650.0, 532.0, 450.0);  // RGB in nm

    // Transmission angle from Snell's law
    let cos_theta_t = snells_law(cos_theta, n_film);

    // Optical path difference
    let optical_path = 2.0 * n_film * thickness_nm * cos_theta_t;

    // Phase including π shift from reflection
    let phase = 2.0 * PI * optical_path / wavelengths + PI;

    // Interference intensity per channel
    let intensity = 0.5 * (vec3(1.0) + cos(phase));

    // Combine with Fresnel reflection
    let fresnel = fresnel_schlick(cos_theta, n_film);

    return intensity * fresnel * 4.0;  // Scale for visibility
}
```

### Lesson Learned

Physically-based rendering requires balancing accuracy with visual appeal. The 4x intensity multiplier is physically "wrong" but necessary for the colors to be visible.

---

## Animation: Camera Rotation vs Geometry Rotation

### Problem

When implementing auto-rotation of the bubble, rotating the geometry via vertex shader produced **non-smooth, jerky motion**.

### Initial Approach (Vertex Shader Rotation)

The first implementation applied Rodrigues rotation formula in the vertex shader:

```wgsl
fn rotate_around_axis(v: vec3<f32>, axis: vec3<f32>, angle: f32) -> vec3<f32> {
    let c = cos(angle);
    let s = sin(angle);
    let k = normalize(axis);
    return v * c + cross(k, v) * s + k * dot(k, v) * (1.0 - c);
}

@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
    // Rotate every vertex every frame
    let pos = rotate_around_axis(in.position, axis, angle);
    let norm = rotate_around_axis(in.normal, axis, angle);
    // ...
}
```

### Root Cause

The vertex shader rotation had several issues:

1. **Per-vertex computation** - At subdivision level 3, ~32k vertices each computing trig functions
2. **Uniform buffer overhead** - Required 4 extra floats (angle + axis) in the uniform buffer
3. **Shader complexity** - More instructions per vertex, potential for precision issues

### Solution: Camera-Based Rotation

Instead of rotating the geometry, rotate the camera's viewpoint:

```rust
// In update() - just increment camera yaw
if self.rotation_playing {
    self.camera.yaw += dt * self.rotation_speed;
    if self.camera.yaw > std::f32::consts::TAU {
        self.camera.yaw -= std::f32::consts::TAU;
    }
}
```

The camera already uses yaw/pitch for its orbit controls, so auto-rotation simply animates the yaw angle.

### Benefits

| Aspect | Vertex Rotation | Camera Rotation |
|--------|-----------------|-----------------|
| Computation | ~32k vertices × trig ops | 1 matrix rebuild |
| Smoothness | Jerky | Smooth |
| Code complexity | Rodrigues formula in shader | Single float increment |
| Uniform buffer | 80 bytes (with rotation fields) | 64 bytes |
| Shader stages | VERTEX_FRAGMENT visibility | FRAGMENT only |

### Simplified Shader

After removing vertex rotation:

```wgsl
@vertex
fn vs_main(in: VertexInput) -> VertexOutput {
    var out: VertexOutput;
    out.world_pos = in.position;
    out.normal = normalize(in.normal);
    out.uv = in.uv;
    out.clip_position = camera.view_proj * vec4<f32>(in.position, 1.0);
    return out;
}
```

### Lesson Learned

For smooth rotation animation of static geometry, prefer moving the camera/viewpoint rather than transforming geometry. The view matrix is computed once per frame on the CPU, while vertex transformations run for every vertex on the GPU. Additionally, the existing orbit camera infrastructure can often be reused for auto-rotation.

---

## MSAA (Multi-Sample Anti-Aliasing) Implementation

### Problem

The bubble's silhouette edge (where rendered geometry meets background) appeared **jagged/aliased** with hard pixel boundaries.

### Root Cause

MSAA was disabled in the render pipeline:

```rust
multisample: wgpu::MultisampleState {
    count: 1,  // Single sample = hard pixel edges
    mask: !0,
    alpha_to_coverage_enabled: false,
},
```

With `count: 1`, each pixel's coverage is determined by a single sample point at the pixel center.

### Solution

Enable 4x MSAA with proper texture setup:

1. **Create MSAA render target** - A texture with `sample_count: 4` matching the surface format
2. **Create matching depth texture** - Depth buffer must have the same sample count
3. **Update render pipeline** - Set `MultisampleState.count` to 4
4. **Configure render pass** - Render to MSAA texture, resolve to swap chain

### Key Implementation Details

```rust
// MSAA texture creation
fn create_msaa_texture(device: &Device, config: &SurfaceConfiguration, sample_count: u32) -> TextureView {
    let texture = device.create_texture(&TextureDescriptor {
        label: Some("MSAA Texture"),
        size: Extent3d { width: config.width, height: config.height, depth_or_array_layers: 1 },
        sample_count,  // Must match pipeline
        format: config.format,
        usage: TextureUsages::RENDER_ATTACHMENT,
        // ...
    });
    texture.create_view(&TextureViewDescriptor::default())
}

// Render pass with MSAA resolve
color_attachments: &[Some(RenderPassColorAttachment {
    view: &msaa_texture,       // Render to MSAA texture
    resolve_target: Some(&swap_chain_view),  // Resolve to swap chain
    ops: Operations { load: LoadOp::Clear(...), store: StoreOp::Store },
})],
```

### Critical Constraints: Sample Count Support

**Not all sample counts are supported on all hardware!**

The WebGPU spec only guarantees support for sample counts **1 and 4** for `Depth32Float` format.

```
Sample count 2 is not supported by format Depth32Float on this device.
Sample count 8 is not supported by format Depth32Float on this device.
The WebGPU spec guarantees [1, 4] samples are supported by this format.
```

**Lesson:** Only offer 1x (off) and 4x MSAA options in the UI. Do not assume 2x or 8x will work.

### Separate Render Passes for MSAA + egui

When using MSAA for 3D content but rendering egui (2D UI) without MSAA:

1. **Bubble pass**: Render to MSAA texture → resolve to swap chain
2. **egui pass**: Render directly to swap chain (no depth attachment needed)

```rust
// egui renderer - no depth, no MSAA
let egui_renderer = egui_wgpu::Renderer::new(&device, surface_format, None, 1, false);

// egui render pass - loads from resolved swap chain
color_attachments: &[Some(RenderPassColorAttachment {
    view: &swap_chain_view,  // Resolved from MSAA
    resolve_target: None,     // No MSAA for 2D UI
    ops: Operations { load: LoadOp::Load, store: StoreOp::Store },
})],
depth_stencil_attachment: None,  // No depth for 2D overlay
```

### Dynamic MSAA Switching

To allow runtime MSAA toggling:

1. Store `bind_group_layout` for pipeline recreation
2. Recreate render pipeline with new `MultisampleState.count`
3. Recreate depth and MSAA textures with new sample count
4. Handle the "no MSAA" case (sample_count=1): render directly to swap chain without resolve

```rust
let (color_view, resolve_target) = if msaa_samples > 1 {
    (&self.msaa_texture, Some(&swap_chain_view))
} else {
    (&swap_chain_view, None)  // No MSAA: render directly
};
```

### Lesson Learned

1. MSAA smooths geometric edges (silhouettes) but not texture/shader aliasing
2. Only 1x and 4x sample counts are universally supported
3. All multisampled textures (color + depth) must have matching sample counts
4. egui and other 2D overlays should render in a separate pass after MSAA resolve
5. Pipeline recreation is required to change MSAA at runtime

---

## LOD (Level of Detail) System

### Problem

Fixed mesh resolution (~32k triangles) regardless of camera distance wastes GPU resources when the bubble is far away and provides insufficient detail when very close.

### Solution

Implement a lazy-caching LOD system with distance-based automatic switching.

### Architecture

```rust
/// Lazy-caching mesh storage for LOD levels 1-5
pub struct LodMeshCache {
    meshes: [Option<SphereMesh>; 5],  // Generated on first access
    aspect_ratio: f32,                 // Cache invalidation key
    radius: f32,
}

impl LodMeshCache {
    pub fn get_mesh(&mut self, level: u32) -> &SphereMesh {
        // Lazy generation: only create mesh when first requested
        if self.meshes[index].is_none() {
            self.meshes[index] = Some(SphereMesh::new_ellipsoid(...));
        }
        self.meshes[index].as_ref().unwrap()
    }
}
```

### Distance Thresholds

Based on camera distance to bubble center:

| Distance | LOD Level | Segments | Triangles |
|----------|-----------|----------|-----------|
| < 0.08m  | 5         | 512      | ~524k     |
| 0.08-0.15m | 4       | 256      | ~131k     |
| 0.15-0.30m | 3       | 128      | ~32k      |
| 0.30-0.60m | 2       | 64       | ~8k       |
| > 0.60m  | 1         | 32       | ~2k       |

Formula: `segments = 16 * 2^level`, triangles ≈ `2 * segments²`

### Key Implementation Details

**1. Lazy Generation**
Meshes are only generated when first accessed, not all at startup:
```rust
pub fn get_mesh(&mut self, level: u32) -> &SphereMesh {
    let index = (level.clamp(1, 5) - 1) as usize;
    if self.meshes[index].is_none() {
        self.meshes[index] = Some(SphereMesh::new_ellipsoid(...));
    }
    self.meshes[index].as_ref().unwrap()
}
```

**2. Cache Invalidation**
When aspect ratio changes (deformation), all cached meshes must be regenerated:
```rust
pub fn update(&mut self, radius: f32, aspect_ratio: f32) -> bool {
    if parameters_changed {
        self.invalidate();  // Clear all cached meshes
        true
    } else {
        false
    }
}
```

**3. Buffer Recreation on LOD Switch**
GPU buffers are immutable, so switching LOD requires creating new buffers:
```rust
fn switch_lod(&mut self, level: u32) {
    let mesh = self.lod_cache.get_mesh(level);

    // Create new GPU buffers (old ones are dropped)
    self.vertex_buffer = device.create_buffer_init(...);
    self.index_buffer = device.create_buffer_init(...);
    self.num_indices = mesh.indices.len() as u32;
}
```

**4. Per-Frame LOD Check**
LOD selection runs every frame but buffer recreation only happens on level change:
```rust
fn update_lod(&mut self) {
    if !self.lod_enabled { return; }

    let new_level = self.select_lod_level();
    if new_level != self.current_lod_level {
        self.switch_lod(new_level);  // Only on actual change
    }
}
```

### UI Integration

When Auto LOD is enabled, the manual subdivision slider is hidden:
```rust
ui.checkbox(lod_enabled, "Auto LOD");
if *lod_enabled {
    ui.label(format!("LOD Level: {} ({} tri)", level, triangles));
} else {
    ui.add(egui::Slider::new(subdivision, 1..=5).text("Mesh detail"));
}
```

### Performance Considerations

1. **Memory**: Only active LOD level consumes GPU memory; cache stores CPU-side mesh data
2. **Switching Cost**: Buffer creation is O(vertices), but happens infrequently
3. **No Popping**: Instant switching works well for smooth sphere; geomorphing optional

### Lesson Learned

1. Lazy generation avoids startup cost for unused LOD levels
2. Cache invalidation is critical when mesh parameters (aspect ratio) change
3. Distance thresholds should be tuned based on screen coverage, not absolute distance
4. For simple geometry like spheres, instant LOD switching is acceptable without blending
5. Separating mesh cache from GPU buffers allows flexible memory management

---

## GPU Drainage Simulation

### Problem

CPU-based drainage simulation (in `DrainageSimulator`) was too slow for real-time physics at high grid resolution. The PDE solver iterates over each grid cell sequentially.

### Solution

Move the drainage PDE solver to GPU compute shaders with double-buffered storage for safe parallel updates.

### Architecture

```rust
/// GPU-based drainage simulator with double-buffered storage
pub struct GPUDrainageSimulator {
    thickness_buffers: [wgpu::Buffer; 2],  // Double-buffering for read/write
    current_buffer: usize,                  // Alternates 0↔1 each step
    params_buffer: wgpu::Buffer,            // Uniform parameters
    compute_pipeline: wgpu::ComputePipeline,
    bind_groups: [wgpu::BindGroup; 2],      // For both buffer directions
}
```

### Double-Buffering Pattern

The key challenge is that GPU shaders can't safely read from and write to the same buffer location. Solution: use two buffers and alternate:

```
Step 1: Read from A → Write to B
Step 2: Read from B → Write to A
Step 3: Read from A → Write to B
...
```

Implementation:
```rust
// Create bind groups for both directions
let bind_groups = [
    // A → B (read from A, write to B)
    device.create_bind_group(&BindGroupDescriptor {
        entries: &[
            BindGroupEntry { binding: 0, resource: buffers[0].as_entire_binding() }, // read
            BindGroupEntry { binding: 1, resource: buffers[1].as_entire_binding() }, // write
        ],
    }),
    // B → A (read from B, write to A)
    device.create_bind_group(&BindGroupDescriptor {
        entries: &[
            BindGroupEntry { binding: 0, resource: buffers[1].as_entire_binding() }, // read
            BindGroupEntry { binding: 1, resource: buffers[0].as_entire_binding() }, // write
        ],
    }),
];

// Each step swaps which bind group is used
fn step(&mut self, encoder: &mut CommandEncoder) {
    compute_pass.set_bind_group(0, &self.bind_groups[self.current_buffer], &[]);
    compute_pass.dispatch_workgroups(workgroups_x, workgroups_y, 1);
    self.current_buffer = 1 - self.current_buffer;  // Swap for next step
}
```

### Compute Shader Structure

The drainage compute shader (`shaders/drainage.wgsl`) implements the thin-film drainage PDE:

```wgsl
struct DrainageParams {
    dt: f32,              // Time step
    gravity: f32,         // Gravitational acceleration
    viscosity: f32,       // Dynamic viscosity
    density: f32,         // Fluid density
    diffusion_coeff: f32, // Surface diffusion
    bubble_radius: f32,   // For Laplacian calculation
    grid_width: u32,
    grid_height: u32,
};

@group(0) @binding(0) var<storage, read> thickness_in: array<f32>;
@group(0) @binding(1) var<storage, read_write> thickness_out: array<f32>;
@group(0) @binding(2) var<uniform> params: DrainageParams;

@compute @workgroup_size(16, 16)
fn drainage_step(@builtin(global_invocation_id) id: vec3<u32>) {
    // Drainage equation: dh/dt = -ρgh³/(3η) * sin(θ) + D∇²h
    let drainage_term = -drainage_coeff * h_cubed * sin_theta;
    let diffusion_term = diffusion_coeff * laplacian;
    thickness_out[idx] = h + (drainage_term + diffusion_term) * dt;
}
```

### Integration with Render Loop

Compute passes run before render passes in the same command encoder:

```rust
fn render(&mut self, window: &Window) -> Result<(), SurfaceError> {
    let mut encoder = device.create_command_encoder(...);

    // GPU drainage simulation (compute)
    if self.gpu_drainage_enabled {
        self.gpu_drainage.step(&mut encoder, dt);
    }

    // 3D render pass (graphics)
    {
        let render_pass = encoder.begin_render_pass(...);
        // Draw bubble...
    }

    // 2D UI pass (graphics)
    {
        let render_pass = encoder.begin_render_pass(...);
        // Draw egui...
    }

    queue.submit(std::iter::once(encoder.finish()));
}
```

### Key Implementation Details

**1. Grid Layout**
- Grid stored in row-major order: `index = theta_idx * grid_width + phi_idx`
- Theta (polar): 0 to π (top to bottom of sphere)
- Phi (azimuthal): 0 to 2π (periodic boundary)

**2. Boundary Conditions**
- Periodic in phi (azimuthal): wraps around
- Special handling at poles (theta = 0, π): averaged from neighboring ring

**3. Workgroup Dispatch**
```rust
let workgroups_x = (grid_width + 15) / 16;   // Ceiling division
let workgroups_y = (grid_height + 15) / 16;
compute_pass.dispatch_workgroups(workgroups_x, workgroups_y, 1);
```

**4. Time Scaling**
GPU drainage runs faster than real-time for visible effects:
```rust
time_scale: f32,        // Default: 100x
steps_per_frame: u32,   // Multiple iterations per frame
```

### Lesson Learned

1. Double-buffering is essential for GPU parallel updates where each cell depends on neighbors
2. Compute passes can share the same command encoder as render passes
3. Bind groups pre-encode buffer bindings, so create one for each buffer direction
4. Grid resolution (e.g., 128×64) can be much higher than practical for CPU iteration
5. Time scaling allows physics to run faster than real-time for visualization
6. Boundary conditions (poles, periodic edges) need explicit handling in the shader

---

## Marangoni Effect Implementation

### Problem

Soap bubbles exhibit beautiful swirling patterns driven by surface tension gradients. The basic drainage model only accounts for gravitational drainage, missing the self-healing behavior where surfactant redistributes to stabilize thin regions.

### Physics Background

The Marangoni effect occurs when surface tension gradients drive fluid flow:

1. **Surface tension depends on surfactant concentration:**
   ```
   γ(Γ) = γ_air - γ_r × Γ
   ```
   Where Γ is surfactant concentration (0-1), γ_air is clean interface tension (~0.072 N/m for water), γ_r is reduction rate (~0.045 N/m).

2. **Marangoni stress from concentration gradient:**
   ```
   τ = -γ_r × ∇Γ
   ```
   This drives flow from regions of low surface tension (high surfactant) to high surface tension (low surfactant).

3. **Coupled system:**
   - Thickness evolves with drainage + Marangoni coupling
   - Concentration evolves with diffusion + thickness coupling

### Solution

Extend the GPU drainage simulator to track surfactant concentration and compute Marangoni stress coupling.

### Extended Uniform Structure

```rust
pub struct DrainageParams {
    // ... existing fields ...
    // Marangoni parameters
    pub marangoni_enabled: u32,      // 0 or 1
    pub gamma_air: f32,              // N/m (clean interface)
    pub gamma_reduction: f32,        // N/m per concentration
    pub surfactant_diffusion: f32,   // m²/s
    pub marangoni_coeff: f32,        // Stress coefficient
}
```

### Double-Buffered Concentration

Just like thickness, concentration needs double-buffering for safe parallel updates:

```rust
pub struct GPUDrainageSimulator {
    thickness_buffers: [wgpu::Buffer; 2],
    concentration_buffers: [wgpu::Buffer; 2],  // NEW
    // ...
}
```

### Coupled Shader Logic

```wgsl
@compute @workgroup_size(16, 16)
fn drainage_step(@builtin(global_invocation_id) global_id: vec3<u32>) {
    // ... get neighbors for both thickness and concentration ...

    // THICKNESS EVOLUTION
    let drainage_term = -drainage_coeff * h_cubed * sin_theta;
    let h_diffusion = params.diffusion_coeff * h_laplacian;

    // Marangoni coupling to thickness
    var marangoni_term = 0.0;
    if (params.marangoni_enabled != 0u) {
        let dc_dtheta = (c_theta_plus - c_theta_minus) / (2.0 * delta_theta);
        let dc_dphi = (c_phi_plus - c_phi_minus) / (2.0 * delta_phi);
        let grad_c_mag = sqrt(grad_c_theta^2 + grad_c_phi^2);
        let marangoni_stress = params.gamma_reduction * grad_c_mag;
        marangoni_term = params.marangoni_coeff * marangoni_stress * h * h;
    }

    thickness_out[idx] = h + dt * (drainage_term + h_diffusion + marangoni_term);

    // CONCENTRATION EVOLUTION
    let c_diffusion = params.surfactant_diffusion * c_laplacian;
    var dc_dt = c_diffusion;

    if (params.marangoni_enabled != 0u) {
        // Coupling: surfactant follows thickness gradients
        dc_dt += coupling_coeff * h_laplacian * conc;
    }

    concentration_out[idx] = clamp(conc + dt * dc_dt, 0.0, 1.0);
}
```

### Bind Group Extension

The bind group layout must include concentration buffers:

```rust
// Binding 0: thickness_in (read)
// Binding 1: thickness_out (write)
// Binding 2: params (uniform)
// Binding 3: concentration_in (read)   // NEW
// Binding 4: concentration_out (write) // NEW
```

### Physical Behavior

The Marangoni effect produces:

1. **Self-healing**: Thin regions (high concentration) push fluid toward thick regions (low concentration), stabilizing the film

2. **Swirling patterns**: Concentration gradients drive surface flows that create organic, dynamic patterns

3. **Counter-drainage**: Marangoni stress can partially counteract gravitational drainage, explaining why soap bubbles last longer than pure water films

### Lesson Learned

1. Coupled PDEs require careful buffer management - both fields need double-buffering
2. WGSL uses function syntax (`sqrt(x)`) not method syntax (`x.sqrt()`)
3. The Marangoni coefficient needs tuning for visual effect - too high causes instability
4. Initialization matters: starting with uniform concentration allows gradients to develop naturally
5. The coupling is bidirectional: thickness affects concentration and vice versa

---

## Multi-Bubble Foam System

### Problem

The simulation was limited to a single bubble. Real soap bubble behavior includes:
- Bubble clusters and foam formation
- Inter-bubble forces (Van der Waals attraction, collision)
- Coalescence (bubble merging)
- Plateau's rules for foam geometry (120° angles at junctions)

### Solution

Implement a multi-bubble foam system with:
1. Data structures for bubbles and clusters
2. N-body physics simulation
3. Spatial hashing for efficient neighbor queries
4. Instance-based rendering preparation

### Architecture

```rust
/// Individual bubble in the foam
pub struct Bubble {
    pub id: BubbleId,
    pub position: Vec3,
    pub radius: f32,
    pub velocity: Vec3,
    pub aspect_ratio: f32,
    pub thickness_nm: f32,
    pub neighbors: Vec<BubbleId>,
}

/// Collection of interacting bubbles
pub struct BubbleCluster {
    bubbles: Vec<Bubble>,
    spatial_hash: SpatialHash,
    connections: Vec<BubbleConnection>,
}

/// Physics simulator for foam dynamics
pub struct FoamSimulator {
    pub cluster: BubbleCluster,
    pub surface_tension: f32,
    pub van_der_waals_strength: f32,
    pub repulsion_stiffness: f32,
}
```

### Physics Model

**Van der Waals Attraction:**
```
F_vdw = A * r_a * r_b / d²  (for d > r_a + r_b)
```
Long-range attraction that draws bubbles together.

**Collision Repulsion (Hertzian):**
```
F_rep = k * overlap^1.5  (when overlap > 0)
```
Prevents bubbles from interpenetrating.

**Buoyancy:**
```
F_buoyancy = ρ_air * g * V_bubble - m_film * g
```
Light soap bubbles rise due to the air inside being less dense than the thin film.

### Spatial Hashing

For efficient O(1) neighbor queries instead of O(n²) brute force:

```rust
pub struct SpatialHash {
    cell_size: f32,  // ~2x max bubble radius
    cells: HashMap<(i32, i32, i32), Vec<BubbleId>>,
}

impl SpatialHash {
    fn cell_coords(&self, position: Vec3) -> (i32, i32, i32) {
        (
            (position.x / self.cell_size).floor() as i32,
            (position.y / self.cell_size).floor() as i32,
            (position.z / self.cell_size).floor() as i32,
        )
    }

    fn query(&self, position: Vec3, radius: f32) -> Vec<BubbleId> {
        // Query neighboring cells
    }
}
```

### Bubble Connections (Young-Laplace)

When two bubbles touch, the shared wall curvature is determined by pressure difference:

```rust
/// Young-Laplace: ΔP = 4γ/R (for soap bubble with two interfaces)
let p_a = 4.0 * surface_tension / bubble_a.radius;
let p_b = 4.0 * surface_tension / bubble_b.radius;

/// Shared wall curvature: R_wall = 2γ / |ΔP|
let wall_curvature = if delta_p.abs() > 1e-6 {
    2.0 * surface_tension / delta_p
} else {
    f32::INFINITY  // Flat wall for equal-sized bubbles
};
```

### Instance Rendering Preparation

Per-instance data for GPU instancing (future optimization):

```rust
#[repr(C)]
pub struct BubbleInstance {
    pub model_0: [f32; 4],    // Model matrix row 0
    pub model_1: [f32; 4],    // Model matrix row 1
    pub model_2: [f32; 4],    // Model matrix row 2
    pub model_3: [f32; 4],    // Model matrix row 3
    pub radius: f32,
    pub aspect_ratio: f32,
    pub thickness_nm: f32,
    pub refractive_index: f32,
}
```

### Lesson Learned

1. Spatial hashing is essential for N-body simulations - O(1) vs O(n²)
2. Young-Laplace equation governs shared wall geometry between bubbles
3. Semi-implicit Euler integration is stable for soft-body physics
4. Separating physics (FoamSimulator) from rendering (FoamRenderer) enables flexibility
5. Incremental integration (UI toggle, then rendering) reduces risk

---

## Edge Smoothing Modes

### Problem

The bubble's edge transparency follows a simple linear falloff (`1 - cos(θ)`), which produces sharp edges that can look unnatural or harsh.

### Solution

Implement selectable edge smoothing curves that provide different visual aesthetics:

```wgsl
// In bubble.wgsl fragment shader
let edge_factor = 1.0 - cos_theta;
var smooth_edge: f32;
if (bubble.edge_smoothing_mode == 1u) {
    // Smoothstep: S-curve easing for gradual transition
    smooth_edge = edge_factor * edge_factor * (3.0 - 2.0 * edge_factor);
} else if (bubble.edge_smoothing_mode == 2u) {
    // Power falloff: softer edges with pow(x, 1.5)
    smooth_edge = pow(edge_factor, 1.5);
} else {
    // Linear (original behavior)
    smooth_edge = edge_factor;
}
let alpha = bubble.base_alpha + bubble.edge_alpha * smooth_edge;
```

### Smoothing Modes

| Mode | Formula | Visual Effect |
|------|---------|---------------|
| Linear (0) | `x` | Sharp edges, original behavior |
| Smoothstep (1) | `x²(3-2x)` | S-curve, gradual transition |
| Power (2) | `x^1.5` | Softer edges, subtle falloff |

### Uniform Buffer Extension

Added `edge_smoothing_mode: u32` to `BubbleUniform` with proper padding:

```wgsl
struct BubbleUniform {
    // ... existing fields ...
    edge_smoothing_mode: u32,
    _padding1: u32,
    _padding2: u32,
    _padding3: u32,
};
```

### Lesson Learned

1. Small visual tweaks (edge smoothing) can significantly improve perceived quality
2. Providing multiple options lets users choose their preferred aesthetic
3. The smoothstep function (`3x² - 2x³`) is a standard shader technique for natural-looking transitions
